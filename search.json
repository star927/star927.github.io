[{"categories":["Notes"],"content":"SSH服务，全称为Secure Shell，是一种网络协议，为用户提供安全的远程访问和文件传输服务。 ","date":"2024-09-21","objectID":"/posts/notes/ssh/:0:0","tags":["SSH"],"title":"SSH Notes","uri":"/posts/notes/ssh/"},{"categories":["Notes"],"content":"ssh命令 ssh [-p port] username@address # 连接远程服务器 ssh -T git@github.com # 测试 SSH 连接 ","date":"2024-09-21","objectID":"/posts/notes/ssh/:1:0","tags":["SSH"],"title":"SSH Notes","uri":"/posts/notes/ssh/"},{"categories":["Notes"],"content":"ssh-keygen命令 ssh-keygen命令允许用户创建用于SSH公钥身份验证的密钥对，包括私钥和公钥。私钥应该被安全地保存在本地机器上，而公钥则可以复制到远程服务器上，以便进行无密码的SSH登录。 ssh-keygen -t rsa -t：指定生成密钥所用的算法（如rsa、ecdsa、ed25519等），不指定则使用默认算法 -C：为密钥对添加注释 -b：指定密钥的位数（长度） -f：指定私钥文件的路径，不指定路径默认在~/.ssh文件夹下，公钥文件名比私钥文件名多了.pub ssh-keygen -R 123.45.67.89 # 从 ~/.ssh/known_hosts 删除指定远程主机 ssh-keygen -l -f ~/.ssh/id_rsa # 查看指定公钥的指纹(fingerprint) ssh-keygen -l -f ~/.ssh/id_rsa.pub # 查看指定公钥的指纹(fingerprint) ","date":"2024-09-21","objectID":"/posts/notes/ssh/:2:0","tags":["SSH"],"title":"SSH Notes","uri":"/posts/notes/ssh/"},{"categories":["Notes"],"content":"passphrase 生成公私钥对可选择是否生成passphrase。如果生成SSH公私钥对时，设置了passphrase，那么使用SSH连接服务器时需要输入passphrase。 ","date":"2024-09-21","objectID":"/posts/notes/ssh/:2:1","tags":["SSH"],"title":"SSH Notes","uri":"/posts/notes/ssh/"},{"categories":["Notes"],"content":"ssh-copy-id命令 ssh-copy-id 是一个用于将本地机器的 SSH 公钥复制到远程服务器的 ~/.ssh/authorized_keys 文件的实用工具。这样做之后，你就可以通过SSH免密码登录到远程服务器了，前提是远程服务器的SSH配置允许使用公钥进行身份验证。 ssh-copy-id [-i [identity_file]] [user@]hostname -i [identity_file]：指定公钥文件的路径。当只有一对公私钥可以不指定，当有多对公私钥时需要手动指定想要上传的公钥文件路径。 [user@]hostname：指定远程服务器的用户名和主机名或IP地址。如果不指定用户名，将使用当前用户的用户名。 ","date":"2024-09-21","objectID":"/posts/notes/ssh/:3:0","tags":["SSH"],"title":"SSH Notes","uri":"/posts/notes/ssh/"},{"categories":["Notes"],"content":"scp命令 # 拷贝文件 scp [-P port] [localFilePath] username@address:[severPath] # 本地文件拷贝到远程服务器 scp [-P port] username@address:[severFilePath] [localPath] # 远程服务器文件拷贝到本地 -r：递归复制整个目录 -v：详细方式显示输出 ","date":"2024-09-21","objectID":"/posts/notes/ssh/:4:0","tags":["SSH"],"title":"SSH Notes","uri":"/posts/notes/ssh/"},{"categories":["Notes"],"content":"SSH相关文件 ","date":"2024-09-21","objectID":"/posts/notes/ssh/:5:0","tags":["SSH"],"title":"SSH Notes","uri":"/posts/notes/ssh/"},{"categories":["Notes"],"content":"~/.ssh/id_ed25519 当生成一对SSH公私钥时，如果不指定文件路径，则公私钥文件会放在~/.ssh文件夹下，比如使用ed25519算法生成一对公私钥，那么默认的私钥文件名和公钥文件名分别是id_ed25519和id_ed25519.pub 公钥文件的内容示例 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAINj This is a comment. 公钥文件内容分为三部分，以空格为分隔符。如上，第一部分ssh-ed25519表示该公钥是通过ed25519算法生成的，第二部分是公钥的主体部分，用于在 SSH 连接时验证用户的身份，第但部分是注释。 ","date":"2024-09-21","objectID":"/posts/notes/ssh/:5:1","tags":["SSH"],"title":"SSH Notes","uri":"/posts/notes/ssh/"},{"categories":["Notes"],"content":"~/.ssh/config ~/.ssh/config是SSH配置文件的路径 格式 Host: hostName的别名 HostName: 是目标主机的ip地址 Port: 指定的端口号 User: 指定的登陆用户名 IdentityFile: 指定的私钥文件地址 示例 Host ubuntu HostName 123.45.67.89 User star Host myserver HostName server.example.com User myuser Port 2222 IdentityFile ~/.ssh/id_rsa_myserver 配置完成后，后续可以使用ssh ubuntu代替ssh 123.45.67.89 ","date":"2024-09-21","objectID":"/posts/notes/ssh/:5:2","tags":["SSH"],"title":"SSH Notes","uri":"/posts/notes/ssh/"},{"categories":["Notes"],"content":"~/.ssh/known_hosts ~/.ssh/known_hosts 是一个SSH客户端用来存储已知的远程主机公钥的文件。当首次通过SSH连接到一个新的远程主机时，SSH客户端会提示你接受该主机的公钥并将其添加到 ~/.ssh/known_hosts 文件中。 可使用ssh-keygen -R server.example.com删除~/.ssh/known_hosts文件中远程主机。 ","date":"2024-09-21","objectID":"/posts/notes/ssh/:5:3","tags":["SSH"],"title":"SSH Notes","uri":"/posts/notes/ssh/"},{"categories":["Notes"],"content":"~/.ssh/authorized_keys ~/.ssh/authorized_keys 文件是一个用于存储公钥的文件，允许SSH用户通过公钥认证方式登录到服务器，每一行代表一个公钥。比如使用ssh-copy-id将本机上的公钥拷贝到了远程主机，远程主机的该文件就会储存该公钥。 ","date":"2024-09-21","objectID":"/posts/notes/ssh/:5:4","tags":["SSH"],"title":"SSH Notes","uri":"/posts/notes/ssh/"},{"categories":["Notes"],"content":"Github配置ssh Github主页点击右上角头像，进入设置 在SSH and GPK keys设置中点击New SSH key Title自定义取个名字，Key type默认的Authentication Key即可，将本地的公钥文件的内容复制到Key中，保存。 ","date":"2024-09-21","objectID":"/posts/notes/ssh/:6:0","tags":["SSH"],"title":"SSH Notes","uri":"/posts/notes/ssh/"},{"categories":["Notes"],"content":"报错 失败 ssh: connect to host github.com port 22: Operation timed out 在SSH的配置文件~/.ssh/config添加如下配置 Host github.com HostName ssh.github.com Port 443 ","date":"2024-09-21","objectID":"/posts/notes/ssh/:6:1","tags":["SSH"],"title":"SSH Notes","uri":"/posts/notes/ssh/"},{"categories":["Notes"],"content":"Ubuntu上使用SSH服务 apt install openssh-server # 安装 SSH 服务 # service 命令是较旧的方式，仍然可用以兼容老旧系统。 service ssh status # 查看 SSH 状态 service ssh start # 启动 SSH 服务 service ssh restart # 重启 SSH 服务 service ssh stop # 停止 SSH 服务 # systemctl 是更现代的命令，适用于使用 systemd 的系统，提供更丰富的功能和信息。 systemctl status ssh # 查看 SSH 状态 systemctl start ssh # 启动 SSH 服务 systemctl restart ssh # 重启 SSH 服务 systemctl stop ssh # 停止 SSH 服务 systemctl enable ssh # 启用开机自启 systemctl disable ssh # 禁用开机自启 ","date":"2024-09-21","objectID":"/posts/notes/ssh/:7:0","tags":["SSH"],"title":"SSH Notes","uri":"/posts/notes/ssh/"},{"categories":["Notes"],"content":"Git相关介绍、常用命令总结及使用过程中的遇到的相关问题记录 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:0:0","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"Git相关知识 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:1:0","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"Git工作区域 flowchart LR work[[Workspace\\n工作区]] stage[(Stage\\n暂存区)] repo[(Repository\\n版本库)] remote[(Remote\\n远程仓库)] work--\u003e|git add|stage stage--\u003e|git commit\\ngit commit --amend|repo stage--\u003e|git restore --staged|work repo--\u003e|git push\\ngit push -f|remote repo--\u003e|git reset --soft|stage repo--\u003e|git reset --hard|work repo--\u003e|git checkout branch|work repo--\u003e|git commit --amend|repo remote--\u003e|git fetch|repo remote--\u003e|git pull| work remote--\u003e|git clone| work flowchart LR work[[Workspace\\n工作区]] stage[(Stage\\n暂存区)] repo[(Repository\\n版本库)] remote[(Remote\\n远程仓库)] work--\u003e|git add|stage stage--\u003e|git commit\\ngit commit --amend|repo stage--\u003e|git restore --staged|work repo--\u003e|git push\\ngit push -f|remote repo--\u003e|git reset --soft|stage repo--\u003e|git reset --hard|work repo--\u003e|git checkout branch|work repo--\u003e|git commit --amend|repo remote--\u003e|git fetch|repo remote--\u003e|git pull| work remote--\u003e|git clone| work 工作区：就是在电脑里能看到的目录。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是 Git 的版本库。 暂存区：英文叫stage或index。对应.git目录下的index文件。 远程仓库：托管代码的服务器，Github等。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:1:1","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"文件状态 flowchart LR untracked([untracked]) modified([modified\\ntracked]) staged([staged]) committed([committed]) delete[Deletion of untracked files] undo[Undo changes to tracked files] untracked-.-\u003e|git clean|delete untracked-.-\u003e|git restore|undo untracked \u0026 modified--\u003e|git add|staged staged--\u003e|git restore --staged|untracked \u0026 modified staged--\u003e|git commit|committed flowchart LR untracked([untracked]) modified([modified\\ntracked]) staged([staged]) committed([committed]) delete[Deletion of untracked files] undo[Undo changes to tracked files] untracked-.-\u003e|git clean|delete untracked-.-\u003e|git restore|undo untracked \u0026 modified--\u003e|git add|staged staged--\u003e|git restore --staged|untracked \u0026 modified staged--\u003e|git commit|committed 未跟踪（untrack）：表示文件为新增加的。 已修改（modified/tracked）：表示修改了文件，但还没保存到git仓库中。 已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 已提交（committed）：表示文件已保存在git仓库中。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:1:2","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"Git命令 git add git branch git checkout git cherry-pick git clean git clone git commit git config git diff git fetch git init git log git merge git pull git push git rebase git reflog git remote git reset git restore git show git stash git switch git tag 多数命令有参数-v/--verbose，会打印更详细的信息。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:0","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"相关概念 HEAD 代表了当前工作目录所指向的当前分支的最新提交。HEAD^表示上一个版本，HEAD^^表示上上一个版本，^个数不限，几个^表示落后HEAD几个版本；HEAD~5表示落后HEAD5个版本。 origin是一个远程仓库的默认名称，这个名称并不是强制的，它代表了远程仓库的地址。origin main和origin/main含义相同，表示远程仓库的main分支。再比如 origin/HEAD表示远程仓库默认分支的最新提交，origin v1.0.0表示远程仓库tag为v1.0.0的那次提交。 上游分支：本地分支一般会与远程仓库的某个分支相关联，关联的这个远程分支就称作是这个本地分支的上游分支。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:1","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git config Git配置级别主要有以下3类： 仓库级别local【优先级最高】，对应的文件仓库下的.git/config 用户级别global【优先级次之】，对应的文件是~/.gitconfig 系统级别system【优先级最低】 git config -l # 查看所有配置 git config --local -l # 查看仓库配置 git config --global -l # 用户全局配置 git config --system -l # 系统配置 git config --global user.name \u003cname\u003e # 设置用户名 git config --global user.email \u003cemail\u003e # 设置邮箱 git config --unset config_name # 删除某个配置 git config --global -e/--edit # 编辑配置文件，该命令会显示配置文件的路径 git config --global init.defaultBranch main # 修改默认分支 git config pull.rebase false # 在一个git仓库中，不带--system和--global参数，配置的就是仓库级别 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:2","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git init git init # 初始化，采用默认分支名称。默认分支名称可通过 git config 来配置 git init -b branch_name # 初始化，并制定分支名称 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:3","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git clone 将远程仓库克隆到本地 git clone url # 克隆某个仓库 git clone url \u003clocal_path\u003e # 克隆的文件放在指定文件夹下 git clone --branch \u003cbranch_name/tag_name\u003e url # 克隆某个分支或标签 git clone url # 只下载最近一次的提交历史，下载完后通过git log也只会看到最近一次提交记录 git clone --recursive url 当使用git clone命令克隆一个包含子模块的仓库时，Git会克隆主仓库，但不会自动克隆子模块目录中的内容。子模块目录会保留，但会是空的，或者包含指向提交对象的占位符（通常是一个特殊的提交，表示子模块指向的特定版本）。当在git clone命令中加上--recursive参数时，Git不仅会克隆主仓库，还会自动地初始化并克隆仓库中所有的子模块。 如果已经克隆了一个仓库但没有使用--recursive参数，可以在之后通过git submodule update --init --recursive命令来初始化并更新子模块。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:4","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git add 将文件放入暂存区 git add . # 将当前文件夹下的文件和文件夹放入暂存区 git add file1 file2 # 将指定文件/文件夹放入暂存区 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:5","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git commit 将暂存区中文件提交到版本库 git commit -m \u003cmessage\u003e # 提交暂存区中的文件到版本库 git commit # 以交互的方式填写提交信息 git commit --amend # 修改最近一次的提交信息，如果此时暂存区中有文件，则暂存区中的文件也会被提交到版本库 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:6","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git push 将版本库中推导远程仓库 git push # 将当前分支推到上游分支，当前与上游分支的名称一致才可以使用该命令，否则报错提醒名称不匹配 git push origin branch_name # 将本地main分支(注意不是当前分支)推到远程仓库指定分支 git push origin \u003clocal-branch\u003e:\u003cremote-branch\u003e # 将本地的指定分支推送到远程仓库的指定分支 git push -f # 强制推到远程仓库，比如落后远程仓库时强制推到远程仓库，则会使远程仓库的版本回退 git push origin :branch_name # 删除远端分支 git push origin v1.0.0 # 推送指定标签到远程仓库 git push origin --tags # 推送所有标签到远程仓库 git push origin :refs/tags/v1.0.0 # 删除远程标签 git push --dry-run # 模拟推送操作，而不实际将更改推送到远程仓库 git push --all 这个命令会推送所有本地分支到远程仓库，如果远程仓库中已经存在同名分支，它们将被更新；如果不存在，则会在远程仓库中创建与本地分支同名的新分支。各个本地分支是否有上游分支、其上游分支是不是与本地分支同名，这些对该命令都没有影响。 git push -u origin branch_name 将本地branch_name分支推到远程仓库的branch_name分支上，并设置当前分支的上游分支为远程仓库的branch_name分支。 git push -u origin local-branch:remote-branch 将本地local-branch分支推到远程仓库的remote-branch分支上，并设置当前分支的上游分支为远程仓库的branch_name分支。 注意 先git branch --set-upstream-to再git push与git push -u某些情况下等效。但是git branch --set-upstream-to=origin/branch_name要求origin/branch_name是已存在的分支。而git push -u对于空仓库也可以，它会为这个空仓库创建这个分支并将本地相关分支推上去，同时设置上游分支。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:7","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git remote git remote add origin git@github.com:user_name/repository_name.git # 关联远端仓库 git remote remove origin # 移除 git remote -v # 查看远程仓库地址 注意 git remote add origin只是关联远程仓库地址，没有获取远程仓库分支的信息；此时运行git branch -r就会发现为空（即使关联的是一个非空仓库），运行命令git branch --set-upstream-to=origin/main也会报错（即使远程仓库存在main分支）。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:8","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git fetch 获取远程仓库最新信息。比如远程仓库已经有一些新的提交，git pull是直接下载最新代码到本地，git fetch不会下载最新的代码，只是获取仓库的最新信息，git fetch 之后可通过git status看到落后上游分支，也可通过git log origin/branch_name查看最新log信息。 git fetch # 获取当前分支的上游远程仓库（如origin）的最新信息 git fetch --all # 获取所有配置的远程仓库的最新信息 git fetch origin # 获取origin这个远程仓库的最新信息 git fetch origin main # 只获取origin这个远程仓库main分支的信息 git fetch --unshallow 比如git clone --depth 1只会下载最近一次提交记录，现在需要完整的仓库历史记录，可以使用 git fetch --unshallow使其包含完整的提交历史。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:9","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git pull git pull # 拉取上游分支的代码 git pull origin main # 拉取指定远程仓库的指定分支的代码 如果当前分支不存在上游分支，需要先设置一下上游分支再git pull，或者用git pull origin main指定远程仓库名称和远程分支名称。 %%{init: {'gitGraph': {'mainBranchName': 'origin/main'}} }%% gitGraph commit id: \"C1\" commit id: \"C2\" branch main commit id: \"C3\" checkout origin/main commit id: \"C5\" checkout main commit id: \"C4\" checkout origin/main commit id: \"C6\" checkout main %%{init: {'gitGraph': {'mainBranchName': 'origin/main'}} }%% gitGraph commit id: \"C1\" commit id: \"C2\" branch main commit id: \"C3\" checkout origin/main commit id: \"C5\" checkout main commit id: \"C4\" checkout origin/main commit id: \"C6\" checkout main如果远程分支和本地分支处于不同的提交节点，直接git pull不行，需指定git pull的行为方式 # 采用 git rebase 的方式合并本地的提交和远程的提交 git pull --rebase git pull --rebase=true # 或者添加配置设置 git pull 的默认行为，再使用 git pull git config [--global] pull.rebase true git pull # 采用 git merge 的方式合并本地的提交和远程的提交 git pull --no-rebase git pull --rebase=false # 或者添加配置设置 git pull 的默认行为，再使用 git pull git config [--global] pull.rebase false git pull git pull过程中可能会遇到冲突。git pull --rebase解决冲突的方法与git rebase解决冲突的方法一样，git pull --no-rebase解决冲突的方法与git merge解决冲突的方法一样。 # 只有当本地分支是当前远程分支的直接祖先时，这个命令才会成功执行。 git pull --ff-only # 或者添加配置设置 git pull 的默认行为，再使用 git pull git config [--global] pull.ff only git pull 以参数--rebase, --no-rebase, --ff-only的形式指定git pull的行为的优先级高于配置文件指定git pull的行为。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:10","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git log git log # 查看当前分支的log git log origin/main # 查看远程main分支的log git log branc_name file_path # 查看指定分支指定文件的log git log --pretty=oneline # 指定输出格式，一行显示一条记录, 完整的commit id git log --oneline # 指定输出格式，一行显示一条记录, 简短的commit id git log --stat # 会显示哪些文件有修改，修改了多少行或字节(二进制文件) git log --stat --patch # 会显示文件具体修改内容 git log --graph --oneline # --graph显示分支结构 # 相当于 git log --graph --oneline 的进阶版 git log --graph --pretty=\"%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)\u003c%an\u003e%Creset\" gitGraph commit id: \"C1\" commit id: \"C2\" branch dev commit id: \"C3\" commit id: \"C4\" checkout main commit id: \"C5\" commit id: \"C6\" gitGraph commit id: \"C1\" commit id: \"C2\" branch dev commit id: \"C3\" commit id: \"C4\" checkout main commit id: \"C5\" commit id: \"C6\" git log main..dev # 查看远程dev分支上但不在main分支上的提交，如上图中的C3、C4 git log dev..main # 查看本地main分支上但不在dev分支上的提交，如上图中的C5、C5 git log main...dev # 查看两个分支上不同的提交，如上图中的C3、C4、C5、C6 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:11","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git reflog git reflog # 最近几次操作记录 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:12","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git branch git branch # 列出所有本地分支，当前分支会有显著标记 git branch -r # 列出所有远程分支 git branch -a # 列出所有本地分支和远程分支 git branch name # 创建分支 git branch -d name1 name2 # 删除分支, 当分支上存在未合并的提交就会删除失败 git branch -D name1 name2 # 强制删除分支 git branch -m new_banch_name # 重命名当前分支，new_banch_name分支已存在则报错 git branch -M new_banch_name # 强制重命名当前分支，即使new_banch_name分时已存在 注意 远程分支不能像本地分支一样直接重命名，可先用git push origin :branh_name删除远程分支，再将本地分支推到远程仓库。 git branch --set-upstream-to=origin/main # 设置当前分支的上游分支 git branch --set-upstream-to=origin/main local_branch # 设置指定本地分支的上游分支 git branch --unset-upstream # 取消当前分支与上游分支(相关联的远程仓库分支)的关联 git branch --unset-upstream local_branch # 取消指定分支的上游分支 git branch -v # 查看本地每个分支，包括分支名、分支最新提交的commit-id和commit-message git branch -vv # 还会显示每个分支的上游分支名称 注意 git branch --set-upstream-to=origin/branch_name要求远程仓库branch_name分支必须存在，并且本地有远程仓库branch_name分支的信息；也就是说比如通过git remote add origin关联了一个包含branch_name分支的远程仓库之后，还得使用git fetch命令获取branch_name分支的信息，这时git branch --set-upstream-to=origin/branch_name这条命令才会成功。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:13","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git checkout git checkout branch_name # 切换分支 注意 git checkout branch_name如果本地分支branch_name不存在，但远程仓库分支branch_name存在，则会自动创建本地分支branch_name并设置上游分支；但如果远程仓库分支branch_name也不存在，那么该命令就会报错。 git checkout -b branch_name # 创建并切换分支，不会设置上游分支，即使远程仓库存在同名分支 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:14","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git switch git switch专注于切换分支的功能，相比git checkout在专注性和安全性方面更胜一筹。切换分支只是git checkout的一部分功能。 git switch branch_name 注意 git switch branch_name如果本地分支branch_name不存在，但远程仓库分支branch_name存在，则会自动创建本地分支branch_name并设置上游分支；但如果远程仓库分支branch_name也不存在，那么该命令就会报错。 git switch -c branch_name # 创建并切换分支，不会设置上游分支，即使远程仓库存在同名分支 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:15","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git tag git tag # 查看所有标签 git tag v1.0.0 # 轻量级标签 git tag -a v1.0.0 -m \"version 1.0.0\" # 带注释的标签 git tag -a v1.0.0 # 带注释的标签，接着Git会提示你输入标签消息 git tag -d v1.0.0 # 删除本地标签 注意 git tag v1.0.0给当前分支的最新提交添加标签。添加标签时，工作区存在未跟踪的文件、已修改未暂存的文件、暂存区有未提交的文件都没有关系。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:16","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git restore git restore --staged . # 将当前文件夹下的暂存区中的文件和文件夹放回工作区 git restore --staged file1 file2 # 将暂存区中的指定文件/文件夹放回工作区 git restore . # 撤销对于当前文件夹下的已跟踪文件的修改 git restore file1 file2 # 撤销对于指定已跟踪文件的修改 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:17","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git clean git clean 命令在 Git 版本控制系统中用于移除当前工作目录中未跟踪的文件和目录。使用 git clean 时需要谨慎，因为它会永久删除这些文件。 -f 或 --force：强制执行清理操作，不询问确认。 -i 或 --interactive：以交互模式运行，让用户选择要删除的文件。 -n 或 --dry-run：模拟执行，显示将要删除的文件列表，但不实际删除它们。 -d：同时删除未跟踪的目录。默认情况下，git clean 只删除文件。 git clean -f git clean -fd git clean -fdn ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:18","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git reset git reset [--hard --soft --mixed] [branch_name origin/branch_name HEAD^ commit_id tag_name] git reset --hard将HEAD指针移动到指定的提交，同时丢弃暂存区和工作目录中的所有更改。所有文件的内容与指定的提交保持一致，不会删除未跟踪的文件。 git reset --soft将 HEAD 指针移动到指定的提交，但保留暂存区和工作目录的更改。所有文件的内容与git reset --soft之前还是一样的，除了git reset --soft之前的暂存区和工作目录的更改，其他文件与指定提交间的差异将放到暂存区。 git reset --mixed将 HEAD 指针移动到指定的提交，保留工作目录的更改，但清空暂存区。所有文件的内容与git reset --mixed之前还是一样的，所有文件与指定提交间的差异都将放到工作区。 git reset不带任何--soft、--mixed或--hard选项，那么默认的行为是--mixed。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:19","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git diff git diff # 查看当前分支工作区中所有文件与暂存区或版本库的修改内容 git diff file_path # 查看当前分支工作区中指定文件与版本库修改内容 git diff branch_name file_path # 查看当前分支指定文件与指定分支的区别 git diff branch1 branch2 file_path # 查看指定两个分支最新提交上指定文件的区别 注意 git diff和git diff file_path是工作区中的文件与暂存区或版本库的比较，不包括暂存区与版本库的比较。 git diff branch1 branch2 file_path是版本库上该文件的比较，git diff branch_name file_path是当前分支上的该文件(在版本库、工作区或暂存区都可以)与指定分支版本库之间的比较。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:20","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git show git show # 显示当前分支上最新一次提交的详细信息 git show [branch_name origin/branch_name HEAD^ commit_id tag_name] ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:21","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git cherry-pick TODO git cherry-pick ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:22","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git merge gitGraph commit id: \"C1\" commit id: \"C2\" branch dev commit id: \"C3\" commit id: \"C4\" checkout main commit id: \"C5\" commit id: \"C6\" merge dev id: \"C7\" commit id: \"C8\" checkout dev commit id: \"C9\" gitGraph commit id: \"C1\" commit id: \"C2\" branch dev commit id: \"C3\" commit id: \"C4\" checkout main commit id: \"C5\" commit id: \"C6\" merge dev id: \"C7\" commit id: \"C8\" checkout dev commit id: \"C9\" git merge branch1 branch2 # 将branch1和branch2分支的更改合并到当前所在的分支中 如上图，如果在main分支上git merge dev后，在main分支上会生成一次新的提交C7，该次提交包含了C3和C4所做的修改，新的提交C8是基于C7的。但切回dev分支再提交C9，C9是基于C4的而不是C7。 git merge遇到冲突时，会提示冲突的文件，手动修改完冲突文件的内容后，再git add和git commit就可以；或者git merge --abort放弃合并。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:23","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git rebase gitGraph commit id: \"C1\" commit id: \"C2\" branch dev commit id: \"C3\" checkout main commit id: \"C5\" checkout dev commit id: \"C4\" checkout main commit id: \"C6\" commit id: \"C3-1\" commit id: \"C4-1\" gitGraph commit id: \"C1\" commit id: \"C2\" branch dev commit id: \"C3\" checkout main commit id: \"C5\" checkout dev commit id: \"C4\" checkout main commit id: \"C6\" commit id: \"C3-1\" commit id: \"C4-1\" git rebase branch_name 如上图，当main分支最新提交是C6，dev分支最新提交是C4时，在dev分支上执行git rebase main后，dev分支上的提交C3和C4会按顺序整合到C6后面，变成新的提交C3-1和C4-1，dev分支会来到C4-1处，但main分支还是会在C6处。使用git rebase后新的最新节点的内容和使用git merge后生成的新的提交节点的内容是一致的。 git rebase遇到冲突时，会提示冲突的文件，手动修改完冲突文件的内容后，再git add和git rebase --continue就可以；或者git rebase --abort放弃合并。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:24","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git stash git stash # 保存当前工作进度 git stash -u/--include-untracked # 只有未跟踪的文件时，需要加该参数才能保存 注意 未跟踪的文件、已修改未暂存的文件、暂存区中的文件都会保存。但是如果当前只有未跟踪的文件，需要--include-untracked参数才能保存，否则会提示没有要保存的文件。 git stash save \"\u003cmessage\u003e\" # 保存并附带信息 git stash list # 查看所有stash，每个stash前面都有一个编号 # 可以使用stash的编号来应用一个特定的stash，这会将更改应用到你的工作目录，但不会从stash列表中删除它 # 没指定stash编号则应用最新的stash git stash apply \u003cstash\u003e git stash pop # 应用最新的stash并删除 git stash drop \u003cstash\u003e # 删除一个特定的stash git stash clear # 删除所有stash 一个使用场景是，当想切换分支做其它工作时，需先保存一个stash，之后切换回来再应用保存的stash即可。 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:25","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"git submodule TODO git submodule git submodule add https://github.com/hugo-fixit/FixIt.git themes/FixIt git submodule add -b dev https://github.com/hugo-fixit/FixIt.git themes/FixIt git submodule set-branch -b dev themes/FixIt # # 将子模块分支切换到 dev git submodule update --remote --merge themes/FixIt # 更新子模块 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:2:26","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"Git LFS 将大文件从本地提交到Github仓库需要使用git-lfs，见官网：https://git-lfs.github.com ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:3:0","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":".gitignore # 注释 .DS_Store # 忽略该文件 *.exe # 所有.exe文件 !index.html # 该文件不被忽略 test # 忽略名为test的文件或文件夹 test/ # 忽略名为test的文件夹 /test/ # 根目录下名为test的文件 更多详细内容见官网：https://git-scm.com/docs/gitignore ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:4:0","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"常见报错 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:5:0","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"Failed to connect 失败 Failed to connect to github.com port 443 after 75002 ms: Couldn’t connect to server 在使用了VPN时，配置http代理，如下，7890是代理的端口号，打开ClashX可以查看使用的端口号 git config --global http.proxy 127.0.0.1:7890 git config --global https.proxy 127.0.0.1:7890 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:5:1","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"RPC failed 失败 RPC failed; curl 92 HTTP/2 stream 5 was not closed cleanly: CANCEL (err 8) git clone遇到该问题时，有时再运行一遍git clone命令就可以 指定使用http 1.1，git config --global http.version HTTP/1.1 失败 RPC failed; curl 18 transfer closed with outstanding read data remaining 使用git clone时，可加参数--depth 1 增大缓冲区，git config --global http.postBuffer 536870912 多尝试几遍 ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:5:2","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Notes"],"content":"相关资料 Git 大全 - Gitee Learn Git Branching 【B站最全Git进阶课程】git rebase: 人生无法重来，但代码可以！ ","date":"2024-09-05","objectID":"/posts/notes/git-notes/:6:0","tags":["Git"],"title":"Git Notes","uri":"/posts/notes/git-notes/"},{"categories":["Blog"],"content":"用hugo new content命令可以创建一篇文章，Archetypes就是新建文章的模板。 ","date":"2024-09-04","objectID":"/posts/blog/hugo-archetypes/:0:0","tags":["Blog","Hugo","Archetypes"],"title":"Hugo博客文章模板-Archetypes","uri":"/posts/blog/hugo-archetypes/"},{"categories":["Blog"],"content":"hugo new命令 以hugo new开头的命令有hugo new content、hugo new site等，hugo new默认就是hugo new content，也就是下面两条命令等效。 hugo new posts/my-new-post.md hugo new content posts/my-new-post.md ","date":"2024-09-04","objectID":"/posts/blog/hugo-archetypes/:1:0","tags":["Blog","Hugo","Archetypes"],"title":"Hugo博客文章模板-Archetypes","uri":"/posts/blog/hugo-archetypes/"},{"categories":["Blog"],"content":"新建一篇文章 ","date":"2024-09-04","objectID":"/posts/blog/hugo-archetypes/:2:0","tags":["Blog","Hugo","Archetypes"],"title":"Hugo博客文章模板-Archetypes","uri":"/posts/blog/hugo-archetypes/"},{"categories":["Blog"],"content":"hugo new [path] hugo new posts/my-new-post.md 上面命令用于创建一个新文件content/posts/my-new-post.md，按照下列顺序寻找模板 archetypes/posts.md themes/my-theme/archetypes/posts.md archetypes/default.md themes/my-theme/archetypes/default.md 如果上述文件都不存在，则使用hugo内置的默认模板 ","date":"2024-09-04","objectID":"/posts/blog/hugo-archetypes/:2:1","tags":["Blog","Hugo","Archetypes"],"title":"Hugo博客文章模板-Archetypes","uri":"/posts/blog/hugo-archetypes/"},{"categories":["Blog"],"content":"hugo new –kind [name] [path] hugo new --kind test posts/new-post.md 上面命令用于创建一个新文件content/posts/my-new-post.md，按照下列顺序寻找模板 archetypes/test.md themes/my-theme/archetypes/test.md archetypes/default.md themes/my-theme/archetypes/default.md 如果上述文件都不存在，则使用hugo内置的默认模板 ","date":"2024-09-04","objectID":"/posts/blog/hugo-archetypes/:2:2","tags":["Blog","Hugo","Archetypes"],"title":"Hugo博客文章模板-Archetypes","uri":"/posts/blog/hugo-archetypes/"},{"categories":["Blog"],"content":"新建一篇基于目录的文章 注意 一个文件夹对应一篇博客文章这种方式，文章的文件名应该是index.md ","date":"2024-09-04","objectID":"/posts/blog/hugo-archetypes/:3:0","tags":["Blog","Hugo","Archetypes"],"title":"Hugo博客文章模板-Archetypes","uri":"/posts/blog/hugo-archetypes/"},{"categories":["Blog"],"content":"hugo new [path] hugo new post-bundle/new-post/ 上面命令用于创建一个新文件夹content/post-bundle/new-post/，按照下列顺序寻找模板 archetypes/post-bundle/ themes/my-theme/post-bundle/ 如果上述文件夹都不存在，则创建失败 ","date":"2024-09-04","objectID":"/posts/blog/hugo-archetypes/:3:1","tags":["Blog","Hugo","Archetypes"],"title":"Hugo博客文章模板-Archetypes","uri":"/posts/blog/hugo-archetypes/"},{"categories":["Blog"],"content":"hugo new –kind [name] [path] hugo new --kind post-bundle posts/new-post/ 上面命令用于创建一个新文件夹content/posts/new-post/，按照下列顺序寻找模板 archetypes/post-bundle/ themes/my-theme/post-bundle/ 如果上述文件夹都不存在，则创建失败 ","date":"2024-09-04","objectID":"/posts/blog/hugo-archetypes/:3:2","tags":["Blog","Hugo","Archetypes"],"title":"Hugo博客文章模板-Archetypes","uri":"/posts/blog/hugo-archetypes/"},{"categories":["Blog"],"content":"示例 目录结构 archetypes ├── post-bundle │ └── index.md ├── default.md └── posts.md 一个文章模版示例 --- title: {{ replace .TranslationBaseName \"-\" \" \" | title }} subtitle: date: {{ .Date }} lastmod: categories: tags: collections: draft: true --- \u003c!--more--\u003e ","date":"2024-09-04","objectID":"/posts/blog/hugo-archetypes/:4:0","tags":["Blog","Hugo","Archetypes"],"title":"Hugo博客文章模板-Archetypes","uri":"/posts/blog/hugo-archetypes/"},{"categories":["Blog"],"content":"购买域名 如阿里云、腾讯云、华为云等都可以购买域名，同一个域名不同厂商的价格可能不一样。 ","date":"2021-08-28","objectID":"/posts/blog/github-custom-domain/:1:0","tags":["Blog","Jekyll","Github"],"title":"GitHub Pages绑定个人域名","uri":"/posts/blog/github-custom-domain/"},{"categories":["Blog"],"content":"域名解析 以阿里云为例，进入域名控制台，解析新购买的域名。添加下面两条记录，记录值填写Github Pages的原始域名user-name.github.io，记录类型选择CNAME，比如自己的域名是hxhuxin.top，那么主机记录www对应的网址就是www.hxhuxin.top，主机记录@对应的网址是hxhuxin.top。添加完两条记录后，需等待十几分钟。 ","date":"2021-08-28","objectID":"/posts/blog/github-custom-domain/:2:0","tags":["Blog","Jekyll","Github"],"title":"GitHub Pages绑定个人域名","uri":"/posts/blog/github-custom-domain/"},{"categories":["Blog"],"content":"Github Pages绑定个人域名 进入自己博客对应的仓库，打开【Settings】-【 Pages】， 在Custom domain下填写自己的域名后点击Save，Enforce HTTPS选项可以勾选上，强制使用HTTPS。 点击Save后可能提示绑定不成功，十几分钟后再试一下即可，域名解析需要等待一定的时间。 ","date":"2021-08-28","objectID":"/posts/blog/github-custom-domain/:3:0","tags":["Blog","Jekyll","Github"],"title":"GitHub Pages绑定个人域名","uri":"/posts/blog/github-custom-domain/"},{"categories":["Blog"],"content":"生成一个Github Token 进入Github主页，点击右上角个人头像，【Settings】-【Developer settings】-【Personal access tokens】-【Generate new token】，如下图： Note可自定义，勾选repo。生成Token后，复制Token，之后该Token将不可见，如下图： ","date":"2021-08-28","objectID":"/posts/blog/jsdelivr-image-hosting/:1:0","tags":["Blog","Jekyll","jsDelivr","图床"],"title":"GitHub+jsDelivr+PicGo搭建免费图床","uri":"/posts/blog/jsdelivr-image-hosting/"},{"categories":["Blog"],"content":"配置PicGo PicGo安装完成后，打开图床设置，配置GitHub图床，如下图： Tips: Mac系统打开PicGo后并不会看到PicGo的主界面，在菜单栏中找到PicGo图标，右键点击“打开详细窗口”即可打开PicGo主界面。 设定仓库名：格式是用户名/仓库名，可以新建一个GitHub仓库，专门用作图床 设定分支名：默认分支main即可 设定Token：复制刚刚生成的Token到此处 指定储存路径：如果不填，则之后图片会上传到仓库的根目录下，也可以指定存储路径（路径最后要加/） 设定自定义域名：基于jsDelivr搭建图床，则域名格式为：https://cdn.jsdelivr.net/gh/user/repo@version，如https://cdn.jsdelivr.net/gh/star927/Image-Hosting@main，设置完成后，即可通过https://cdn.jsdelivr.net/gh/user/repo@version/file格式访问文件了，如https://cdn.jsdelivr.net/gh/star927/Image-Hosting@main/202108/PicGo.png 配置完PicGo后，之后就可以通过PicGo快速将图片上传至GitHub仓库了。图片成功上传后，PicGo会自动将图片链接复制到粘贴板。PicGo常用的操作是：选定需要上传的图片，Command+C复制图片；Command+Shift+P上传刚刚复制的图片，Command+V获得图片链接。更多PicGo操作可自行探索。 ","date":"2021-08-28","objectID":"/posts/blog/jsdelivr-image-hosting/:2:0","tags":["Blog","Jekyll","jsDelivr","图床"],"title":"GitHub+jsDelivr+PicGo搭建免费图床","uri":"/posts/blog/jsdelivr-image-hosting/"},{"categories":["Blog"],"content":"配置LeanCloud 进入LeanCloud官网https://www.leancloud.cn/，注册或登录账号。 创建应用，应用名称可自行设定。 创建Class，【数据存储】-【结构化数据】-【创建Class】，Class名称与后面相关代码有关，为减少不必要的麻烦，建议将Class名称设置为Counter，其它设置项默认值即可。 以后每篇文章的点击量等信息都可在该Class下查看。 设置安全域名，【设置】-【安全中心】-【Web安全域名】，填写自己博客的域名即可，在本地调试阶段还可以添加http://127.0.0.1:4000 查看App ID和App Key，【设置】-【应用凭证】-【Credentials】，App ID和App Key在后面的配置中会用到。 安全设置，【设置】-【安全中心】-【服务开关】，由于App ID和App Key会出现在博客的配置文件中，相当于是公开的，所以有必要进行安全设置，关闭不需要的服务。 ","date":"2021-08-28","objectID":"/posts/blog/jekyli-leancloud/:1:0","tags":["Blog","LeanCloud","Jekyll"],"title":"Jekyll博客中基于LeanCloud统计文章阅读量","uri":"/posts/blog/jekyli-leancloud/"},{"categories":["Blog"],"content":"修改博客配置文件 需要修改或新增的文件如下： . ├── _config.yml ├── _includes │ └── leancloud-analytics.html └── _layouts ├── default.html └── post.html ","date":"2021-08-28","objectID":"/posts/blog/jekyli-leancloud/:2:0","tags":["Blog","LeanCloud","Jekyll"],"title":"Jekyll博客中基于LeanCloud统计文章阅读量","uri":"/posts/blog/jekyli-leancloud/"},{"categories":["Blog"],"content":"_config.yml leancloud: enable: true app_id: xxxxxx app_key: xxxxxx enable是一个总开关，控制LeanCould统计功能是否开启，app_id和app_key对应LeanCloud的App ID和App Key ","date":"2021-08-28","objectID":"/posts/blog/jekyli-leancloud/:2:1","tags":["Blog","LeanCloud","Jekyll"],"title":"Jekyll博客中基于LeanCloud统计文章阅读量","uri":"/posts/blog/jekyli-leancloud/"},{"categories":["Blog"],"content":"leancloud-analytics.html 创建leancloud-analytics.html文件，放在_includes文件夹下，代码如下： 代码参考于https://blog.csdn.net/u013553529/article/details/63357382 \u003cscript src=\"https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js\"\u003e\u003c/script\u003e \u003cscript\u003eAV.initialize(\"{{site.leancloud.app_id}}\", \"{{site.leancloud.app_key}}\");\u003c/script\u003e \u003cscript\u003e function showHitCount(Counter) { var query = new AV.Query(Counter); var entries = []; var $visitors = $(\".leancloud_visitors\"); $visitors.each(function () { entries.push( $(this).attr(\"id\").trim() ); }); query.containedIn('url', entries); query.find() .done(function (results) { var COUNT_CONTAINER_REF = '.leancloud-visitors-count'; if (results.length === 0) { $visitors.find(COUNT_CONTAINER_REF).text(0); return; } for (var i = 0; i \u003c results.length; i++) { var item = results[i]; var url = item.get('url'); var hits = item.get('hits'); var element = document.getElementById(url); $(element).find(COUNT_CONTAINER_REF).text(hits); } for(var i = 0; i \u003c entries.length; i++) { var url = entries[i]; var element = document.getElementById(url); var countSpan = $(element).find(COUNT_CONTAINER_REF); if( countSpan.text() == '') { countSpan.text(0); } } }) .fail(function (object, error) { console.log(\"Error: \" + error.code + \" \" + error.message); }); } function addCount(Counter) { var $visitors = $(\".leancloud_visitors\"); var url = $visitors.attr('id').trim(); var title = $visitors.attr('data-flag-title').trim(); var query = new AV.Query(Counter); query.equalTo(\"url\", url); query.find({ success: function(results) { if (results.length \u003e 0) { var counter = results[0]; counter.fetchWhenSave(true); counter.increment(\"hits\"); counter.save(null, { success: function(counter) { var $element = $(document.getElementById(url)); $element.find('.leancloud-visitors-count').text(counter.get('hits')); }, error: function(counter, error) { console.log('Failed to save Visitor num, with error message: ' + error.message); } }); } else { var newcounter = new Counter(); /* Set ACL */ var acl = new AV.ACL(); acl.setPublicReadAccess(true); acl.setPublicWriteAccess(true); newcounter.setACL(acl); /* End Set ACL */ newcounter.set(\"title\", title); newcounter.set(\"url\", url); newcounter.set(\"hits\", 1); newcounter.save(null, { success: function(newcounter) { var $element = $(document.getElementById(url)); $element.find('.leancloud-visitors-count').text(newcounter.get('hits')); }, error: function(newcounter, error) { console.log('Failed to create'); } }); } }, error: function(error) { console.log('Error:' + error.code + \" \" + error.message); } }); } $(function() { var Counter = AV.Object.extend(\"Counter\"); if ($('.leancloud_visitors').length == 1) { /* in post.html, so add 1 to hit counts */ addCount(Counter); } }); \u003c/script\u003e ","date":"2021-08-28","objectID":"/posts/blog/jekyli-leancloud/:2:2","tags":["Blog","LeanCloud","Jekyll"],"title":"Jekyll博客中基于LeanCloud统计文章阅读量","uri":"/posts/blog/jekyli-leancloud/"},{"categories":["Blog"],"content":"default.html 将下面代码添加进_layouts/default.html文件中，这样每一篇博客中都会加载leancloud-analytics.html文件。 {% raw %}{% if site.leancloud.enable %} {% include leancloud-analytics.html %} {% endif %}{% endraw %} ","date":"2021-08-28","objectID":"/posts/blog/jekyli-leancloud/:2:3","tags":["Blog","LeanCloud","Jekyll"],"title":"Jekyll博客中基于LeanCloud统计文章阅读量","uri":"/posts/blog/jekyli-leancloud/"},{"categories":["Blog"],"content":"post.html 想在每篇博客中显示该篇文章的阅读量，可将下面代码添加在_layouts/post.html合适的位置。 {% raw %}{% if site.leancloud.enable %}{% endraw %} \u003cspan\u003e|\u003c/span\u003e \u003ci class=\"far fa-eye\"\u003e\u003c/i\u003e \u003cspan id=\"{{ page.url }}\" class=\"leancloud_visitors\" data-flag-title=\"{{ page.title }}\"\u003e \u003cspan class=\"leancloud-visitors-count\"\u003e\u003c/span\u003e \u003cspan class=\"post-meta-item-text\"\u003e次阅读\u003c/span\u003e \u003c/span\u003e {% raw %}{% endif %}{% endraw %} 效果图如下： 至此，LeanCloud统计功能配置完毕，登录LeanCloud打开上面创建的Class即可进行后台数据管理。 ","date":"2021-08-28","objectID":"/posts/blog/jekyli-leancloud/:2:4","tags":["Blog","LeanCloud","Jekyll"],"title":"Jekyll博客中基于LeanCloud统计文章阅读量","uri":"/posts/blog/jekyli-leancloud/"},{"categories":["Blog"],"content":"Gitalk评论系统的效果图如下： Gitalk每篇文章的评论对应于Github上的一个Issues，配置完Gitalk后，进入博客对应的Github仓库的Issues，就可以管理评论数据了，下面来配置Gitalk评论系统。 ","date":"2021-08-28","objectID":"/posts/blog/jekyll-gitalk/:0:0","tags":["Blog","Jekyll","Gitalk"],"title":"Jekyll博客中添加Gitalk评论系统","uri":"/posts/blog/jekyll-gitalk/"},{"categories":["Blog"],"content":"创建Github OAuth Apps 进入Github主页，点击右上角个人头像，【Settings】-【Developer settings】-【OAuth Apps】-【New OAuth App】，可看到如下界面： Application name: 应用的名字，自定义 Homepage URL: 填写自己博客的URL，如https://star927.github.io/ Application description: 应用描述，选填项 Authorization callback URL: 与Homepage URL一样即可 如果Github Pages已经绑定了个人域名，则Homepage URL和Authorization callback URL需要填写自己的域名，如https://hxhuxin.top/ ","date":"2021-08-28","objectID":"/posts/blog/jekyll-gitalk/:1:0","tags":["Blog","Jekyll","Gitalk"],"title":"Jekyll博客中添加Gitalk评论系统","uri":"/posts/blog/jekyll-gitalk/"},{"categories":["Blog"],"content":"在Jekyll中配置Gitalk 需要修改文件如下： . ├── _config.yml ├── _includes │ └── head.html └── _layouts └── post.html ","date":"2021-08-28","objectID":"/posts/blog/jekyll-gitalk/:2:0","tags":["Blog","Jekyll","Gitalk"],"title":"Jekyll博客中添加Gitalk评论系统","uri":"/posts/blog/jekyll-gitalk/"},{"categories":["Blog"],"content":"_config.yml 在_config.yml文件中添加以下代码： gitalk: enable: true # 总开关，控制gitalk功能是否开启 clientId: 申请的OAuth App的Client ID clientSecret: 申请的OAuth App的Client ID repo: 博客对应的仓库名称 owner: 自己的Github用户名 admin: 自己的Github用户名 distractionFreeMode: true # 若设置为true，则当在评论框输入时，周围区域会变暗 repo是自己博客对应的仓库的名称，如star927.github.io，而不是该仓库的URL ","date":"2021-08-28","objectID":"/posts/blog/jekyll-gitalk/:2:1","tags":["Blog","Jekyll","Gitalk"],"title":"Jekyll博客中添加Gitalk评论系统","uri":"/posts/blog/jekyll-gitalk/"},{"categories":["Blog"],"content":"head.html 找到自己博客\u003chead\u003e标签所在的文件，如_includes/head.html，在\u003c/head\u003e标签前添加以下代码。 {% raw %}{% if page.layout == 'post' and site.gitalk.enable %}{% endraw %} \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\"\u003e {% raw %}{% endif %}{% endraw %} ","date":"2021-08-28","objectID":"/posts/blog/jekyll-gitalk/:2:2","tags":["Blog","Jekyll","Gitalk"],"title":"Jekyll博客中添加Gitalk评论系统","uri":"/posts/blog/jekyll-gitalk/"},{"categories":["Blog"],"content":"post.html 在_layouts/post.html文件的适当位置添加以下代码，这样每篇博客最后都会有Gitalk评论区。 \u003cdiv id=\"gitalk-container\"\u003e\u003c/div\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e const gitalk = new Gitalk ({ id: window.location.pathname, clientID: '{% raw %}{{ site.gitalk.clientId }}{% endraw %}', clientSecret: '{% raw %}{{ site.gitalk.clientSecret }}{% endraw %}', repo: '{% raw %}{{ site.gitalk.repo }}{% endraw %}', owner: '{% raw %}{{ site.gitalk.owner }}{% endraw %}', admin: ['{% raw %}{{ site.gitalk.admin }}{% endraw %}'], distractionFreeMode: '{% raw %}{{ site.gitalk.distractionFreeMode }}{% endraw %}' }); gitalk.render('gitalk-container'); \u003c/script\u003e 上述步骤完成后，在评论区如果出现问题 Error: Not Found.（如下图），请仔细检查代码是否有误。 ","date":"2021-08-28","objectID":"/posts/blog/jekyll-gitalk/:2:3","tags":["Blog","Jekyll","Gitalk"],"title":"Jekyll博客中添加Gitalk评论系统","uri":"/posts/blog/jekyll-gitalk/"},{"categories":["Blog"],"content":"初始化Gitalk 正确完成上述步骤后，在评论区可看到以下内容，点击使用Github登录即可。 必须将上述代码的修改提交到Github上，通过https://your-user-name.github.io/或者自己已绑定的域名访问自己的博客，再点击使用Github登录，而不是在本地服务器http://127.0.0.1:4000/点击使用Github登录。 登录自己的Github账号后，就可以看到Gitalk评论区了。 ","date":"2021-08-28","objectID":"/posts/blog/jekyll-gitalk/:3:0","tags":["Blog","Jekyll","Gitalk"],"title":"Jekyll博客中添加Gitalk评论系统","uri":"/posts/blog/jekyll-gitalk/"},{"categories":["Blog"],"content":"Valine评论系统的效果图如下： 下面一步步来配置Valine评论系统 ","date":"2021-08-28","objectID":"/posts/blog/jekyll-valine/:0:0","tags":["Blog","Valine","Jekyll"],"title":"Jekyll博客中添加Valine评论系统","uri":"/posts/blog/jekyll-valine/"},{"categories":["Blog"],"content":"配置LeanCloud 进入LeanCloud官网https://www.leancloud.cn/，注册/登录账号。 创建应用，应用名称可自行设定。 查看App ID和App Key，【设置】-【应用凭证】-【Credentials】，App ID和App Key在后面的配置中会用到。 ","date":"2021-08-28","objectID":"/posts/blog/jekyll-valine/:1:0","tags":["Blog","Valine","Jekyll"],"title":"Jekyll博客中添加Valine评论系统","uri":"/posts/blog/jekyll-valine/"},{"categories":["Blog"],"content":"修改博客配置文件 在_config.yml文件中添加以下代码： valine: enable: true app_id: xxxxxx app_key: xxxxxx enable是一个总开关，控制Valine评论功能是否开启，app_id和app_key对应LeanCloud的App ID和App Key。 更多配置项参见官方文档：https://valine.js.org/configuration.html 创建valine.html文件，放在_includes文件夹下，代码如下： \u003cscript src='//unpkg.com/valine/dist/Valine.min.js'\u003e\u003c/script\u003e \u003cdiv id=\"vcomments\"\u003e\u003c/div\u003e \u003cscript\u003e new Valine({ el: '#vcomments', appId: '{% raw %}{{ site.valine.app_id }}{% endraw %}', appKey: '{% raw %}{{ site.valine.app_key }}{% endraw %}', }) \u003c/script\u003e 在需要添加Valine评论的地方添加以下代码，如_layouts/post.html文件 {% raw %}{% if site.valine.enable %} {% include valine.html %} {% endif %}{% endraw %} 至此Valine评论系统配置完毕。打开对应的LeanCloud应用，在【数据存储】-【结构化数据】-【Comment\u003c/\u003e】中可查看和管理所有评论数据。 ","date":"2021-08-28","objectID":"/posts/blog/jekyll-valine/:2:0","tags":["Blog","Valine","Jekyll"],"title":"Jekyll博客中添加Valine评论系统","uri":"/posts/blog/jekyll-valine/"},{"categories":["Blog"],"content":"配置Valine邮件提醒功能 详见https://github.com/DesertsP/Valine-Admin ","date":"2021-08-28","objectID":"/posts/blog/jekyll-valine/:3:0","tags":["Blog","Valine","Jekyll"],"title":"Jekyll博客中添加Valine评论系统","uri":"/posts/blog/jekyll-valine/"}]